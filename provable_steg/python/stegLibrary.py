from bitarray import bitarray
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from json import loads
from math import ceil
from secrets import randbits, choice


# Standard text encoding for byte encoding and decoding
text_encoding = 'ascii'


class Dumb_Oracle():
    """A very dumb oracle which stores a history of messages it has seen and generated
    """
    def __init__(self, history: list = [], internal_text_encoding: str = text_encoding) -> None:
        
        self.history = history
        self.text_encoding = internal_text_encoding

    def load_tweets(self, path:str = 'elonmusk_tweets.json') -> None:
        """Load a set of tweets

        Args:
            path (str, optional): Path to a tweets JSON file; Defaults to 'elonmusk_tweets.json'.
        """
        self.history = loads(open(path,'r').read())

    def draw_from_channel(self, history: list = None) -> str:
        """Simulates a b-bit draw from a channel given some history

        Args:
            history (list, optional): A list of previous messages the oracle has seen

        Returns:
            str: A random message drawn from a simulated channel
        """
        if history == None:
            history = self.history

        return choice(history)['text'].encode(self.text_encoding)


def decryptMessage(key: bytes, ciphertext: bytes) -> bytes:
    """Decrypt a ciphertext and return a message

    Args:
        key (bytes): key for decryption
        ciphertext (bytes): ciphertext generated by recovering bits from stegotext

    Returns:
        bytes: decrypted message
    """

    iv = ciphertext[:16]
    ct = ciphertext[16:]

    cipher = Cipher(algorithms.AES(key), modes.CTR(iv))
    decryptor = cipher.decryptor()

    plaintext = decryptor.update(ct) + decryptor.finalize()

    return plaintext

def test_decryptMessage():

    key = bytes.fromhex('786aaa117b41555e5e87842df8f41c6c1262b280333e87309cf53ec8b46731f2')
    ciphertext = '8e50f34929d5b3ebd68d44276a03d9ff' + 'f43d5c8e69de8e980fc2863c93490d'

    assert decryptMessage(key, bytes.fromhex(ciphertext)) == b"Attack at dawn!"


def encryptMessage(key: bytes, message:str, iv: bytes = None) -> bytes:
    """Encrypt a message
    
    For provable stateless steg, the Enc_k() must be CPA secure.

    Args:
        key (bytes): Encryption key
        message (str): A message to be encrypted
        iv (bytes, optional): _description_. Defaults to None.

    Returns:
        bytes: iv||ciphertext as bytes
    """
    if iv == None:
        iv = randbits(128).to_bytes(16, 'little')

    cipher = Cipher(algorithms.AES(key), modes.CTR(iv))
    encryptor = cipher.encryptor()

    ciphertext = encryptor.update((message).encode(text_encoding)) + encryptor.finalize()

    return iv + ciphertext

def test_encrypt():

    key = bytes.fromhex('786aaa117b41555e5e87842df8f41c6c1262b280333e87309cf53ec8b46731f2')
    iv = bytes.fromhex('8e50f34929d5b3ebd68d44276a03d9ff')
    message = "Attack at dawn!"

    if text_encoding == 'ascii':
        assert encryptMessage(key, message, iv).hex() == \
            '8e50f34929d5b3ebd68d44276a03d9ff' + 'f43d5c8e69de8e980fc2863c93490d'


def getRandomInt(numberOfBytes: int) -> int:
    """Get a random integer of size numberOfBytes

    Args:
        numberOfBytes (int): the size of the target integer in bytes

    Returns:
        int: the random integer of size numberOfBytes
    """

    # return int.from_bytes(urandom(numberOfBytes), 'little', signed=False)

    return randbits(numberOfBytes*8)


def getKey(keySizeBits: int = 256) -> bytes:
    """Generate a key of size keySizeBits-bits

    Args:
        keySizeBits (int, optional): Size of the key in bits

    Returns:
        bytes: a random key as bytes
    """

    keyAsInt = randbits(keySizeBits)
    keyBytes = keyAsInt.to_bytes(ceil(keySizeBits/8), 'little', signed=False)
    
    return keyBytes


def messageToBitArray(message: str) -> bitarray:
    """converts a message into a bit array 

    Args:
        message (str): the message to be converted

    Returns:
        bitarray: the message as a bitarray
    """

    message_bits = bitarray()
    message_bits.frombytes(message)

    return message_bits


def stegPRF(key: bytes, bits_output: int, data: bytes) -> bitarray:
    """Given some data, return x bits of PRF_key(data)

    Args:
        key (bytes): the PRF key
        data (bytes): data as input to the PRF

    Returns:
        bitarray: bits_output bits of output from the PRF
    """
    digest = hashes.Hash(hashes.SHA256())
    digest.update(key)
    digest.update(data)
    out = digest.finalize()
    
    ba = bitarray()
    ba.frombytes(out)

    return ba[:bits_output]


def test_regression_encrypt_decrypt():

    key = randbits(256).to_bytes(32, 'little')
    message = "Attack at Dawn!"
    ciphertext = encryptMessage(key, message)
    decrypted_message = decryptMessage(key, ciphertext)

    assert message == decrypted_message.decode(text_encoding)