from distutils.log import debug
from bitarray import bitarray
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.exceptions import InvalidTag
from json import loads, dumps
from math import ceil
from secrets import randbits, choice


# Standard text encoding for byte encoding and decoding
text_encoding = 'utf-8' #'ascii'


class Dumb_Oracle():
    """A very dumb oracle which stores a history of messages it has seen and generated
    """
    def __init__(self, history: list = [], internal_text_encoding: str = text_encoding) -> None:
        
        self.history = history
        self.text_encoding = internal_text_encoding

    def load_tweets(self, path:str = 'elonmusk_tweets.json') -> None:
        """Load a set of tweets

        Args:
            path (str, optional): Path to a tweets JSON file; Defaults to 'elonmusk_tweets.json'.
        """
        self.history = loads(open(path,'r').read())

    def draw_from_channel(self, history: list = None, text: bool = True) -> str:
        """Simulates a b-bit draw from a channel given some history

        Args:
            history (list, optional): A list of previous messages the oracle has seen

        Returns:
            str: A random message drawn from a simulated channel
        """
        if history == None:
            history = self.history

        # This assumptions messages drawn from the channel have high entropy which 
        # is NOT the case for most channels
        if text:
            return choice(history)['text'].encode(self.text_encoding)

        message_from_channel = dumps(choice(history)).encode(self.text_encoding)     
        
        return message_from_channel


def decryptMessage(key: bytes, ciphertext: bytes, cipher_mode:str = 'CTR') -> bytes:
    """Decrypt a ciphertext and return a message

    Args:
        key (bytes): key for decryption
        ciphertext (bytes): ciphertext generated by recovering bits from stegotext
        mode (str, optional): The block mode of decryption. Only CTR and GCM 
            supported. Defaults to 'CTR'

    Returns:
        bytes: decrypted message
    """

    iv = ciphertext[:16]
    ct = ciphertext[16:]

    if cipher_mode.upper() == 'CTR':
        ciphermode = modes.CTR(iv)
    if cipher_mode.upper() == 'GCM':
        tag = ct[-16:]
        ct = ct[:-16]
        ciphermode = modes.GCM(iv,tag)

    cipher = Cipher(algorithms.AES(key), ciphermode)
    decryptor = cipher.decryptor()

    try:
        plaintext = decryptor.update(ct) + decryptor.finalize()
    except InvalidTag as e:
        print(f"The authenticated encryption failed: {e}")
        raise InvalidTag

    return plaintext

def test_decryptMessage():

    key = bytes.fromhex('786aaa117b41555e5e87842df8f41c6c1262b280333e87309cf53ec8b46731f2')
    ciphertext = '8e50f34929d5b3ebd68d44276a03d9ff' + 'f43d5c8e69de8e980fc2863c93490d'

    assert decryptMessage(key, bytes.fromhex(ciphertext)) == b"Attack at dawn!"


def encryptMessage(key: bytes, message:bytes, iv: bytes = None, cipher_mode: str = 'CTR') -> bytes:
    """Encrypt a message
    
    For provable stateless steg, the Enc_k() must be CPA secure.

    Args:
        key (bytes): Encryption key
        message (str): A message to be encrypted
        iv (bytes, optional): A random initialization vector (nonce). Defaults to None
        mode (str, optional): The block mode of encryption. Only CTR and GCM 
            supported. Defaults to 'CTR'

    Returns:
        bytes: iv||ciphertext as bytes
    """
    if iv == None:
        iv = randbits(128).to_bytes(16, 'little')

    if cipher_mode.upper() == 'CTR':
        ciphermode = modes.CTR(iv)
    if cipher_mode.upper() == 'GCM':
        ciphermode = modes.GCM(iv)

    encryptor = Cipher(algorithms.AES(key), ciphermode).encryptor()

    ciphertext = encryptor.update(message) + encryptor.finalize()

    if hasattr(encryptor, 'tag'):
        ciphertext += encryptor.tag

    return iv + ciphertext

def test_encrypt():

    key = bytes.fromhex('786aaa117b41555e5e87842df8f41c6c1262b280333e87309cf53ec8b46731f2')
    iv = bytes.fromhex('8e50f34929d5b3ebd68d44276a03d9ff')
    message = "Attack at dawn!"

    if text_encoding == 'ascii':
        assert encryptMessage(key, message.encode(text_encoding), iv).hex() == \
            '8e50f34929d5b3ebd68d44276a03d9ff' + 'f43d5c8e69de8e980fc2863c93490d'


def getRandomInt(numberOfBytes: int) -> int:
    """Get a random integer of size numberOfBytes

    Args:
        numberOfBytes (int): the size of the target integer in bytes

    Returns:
        int: the random integer of size numberOfBytes
    """

    # return int.from_bytes(urandom(numberOfBytes), 'little', signed=False)

    return randbits(numberOfBytes*8)


def getKey(keySizeBits: int = 256) -> bytes:
    """Generate a key of size keySizeBits-bits

    Args:
        keySizeBits (int, optional): Size of the key in bits

    Returns:
        bytes: a random key as bytes
    """

    keyAsInt = randbits(keySizeBits)
    keyBytes = keyAsInt.to_bytes(ceil(keySizeBits/8), 'little', signed=False)
    
    return keyBytes


def messageToBitArray(message: str) -> bitarray:
    """converts a message into a bit array 

    Args:
        message (str): the message to be converted

    Returns:
        bitarray: the message as a bitarray
    """

    message_bits = bitarray()
    message_bits.frombytes(message)

    return message_bits


def padMessage(
    message: str, 
    bits_per_message: 
    int, text_encoding: str = None, 
    cipher_mode: str = 'CTR', 
    iv_size_bits = 128,
    debug: bool = True) -> bytes:
    
    if text_encoding != None:
        message = message.encode(text_encoding)

    extra_bits = 0
    # Add extra bits due to the AE TAG
    if cipher_mode == 'GCM':
        extra_bits = 128

    message_bits = bitarray()
    message_bits.frombytes(message)
    if debug:
        print(f"Number of message bits: {len(message_bits)}")
        print(f"Number of bits/message: {bits_per_message}")

    number_of_bits_in_array = len(message_bits) + extra_bits + iv_size_bits
    if debug:
        print(f"Number of encrypted message bits: {number_of_bits_in_array}")

    padding_bits = bits_per_message - number_of_bits_in_array % bits_per_message
    if debug:
        print(f"Initial number of padding bits: {padding_bits}")

    # Make sure the padding hits a byte boundary
    while (padding_bits + number_of_bits_in_array)%8 != 0:
         padding_bits += 10
    

    message_bits += padding_bits * bitarray('0')
    if debug:
        print(f"Number of padding bits: {padding_bits}")
        print(f"bits/msg | bits in the calculated encrypted array: {number_of_bits_in_array % bits_per_message}")
        print(f"New number of message bits after padding: {len(message_bits)}")
        print(f"Number of total bits in the array: {number_of_bits_in_array + padding_bits}")

    assert (number_of_bits_in_array + padding_bits) % bits_per_message == 0

    return message_bits.tobytes()


def stegPRF(key: bytes, number_of_bits_in_output: int, data: bytes) -> bitarray:
    """Given some data, return x bits of PRF_key(data)

    Args:
        key (bytes): the PRF key
        number_of_bits_in_output (int): The number of bits in the desired output
        data (bytes): data as input to the PRF

    Returns:
        bitarray: bits_output bits of output from the PRF
    """
    digest = hashes.Hash(hashes.SHA256())
    digest.update(key)
    digest.update(data)
    out = digest.finalize()
    
    ba = bitarray()
    ba.frombytes(out)

    return ba[:number_of_bits_in_output]


def splitBitArrayIntoChunks(bit_array: bitarray, bits_per_chunk: int, debug: bool = False) -> list[bitarray]:
    """Split a bitarray into "bits_per_chunk"-bit chunks. 
    
    Calculate len(array) | bits/chunk. Pop off "bits/chunk" bits of the array into a list. The 
    last chunk may have less than "bits/chunk"; attach these remaining bits as a bitarray to
    the end of the list.

    Example:
        >>> ex_ba = bitarray('110111101101110010110000')
        >>> splitBitArrayIntoChunks(ex_ba, 5)
            [
                bitarray('11011'), 
                bitarray('11011'), 
                bitarray('01110'), 
                bitarray('01011'), 
                bitarray('0000')
            ]

    Args:
        bit_array (bitarray): A bitarray containing some data
        bits_per_chunk (int): The number of desired bits per chunk
        debug (bool, optional): Execute debug output. Defaults to False.

    Returns:
        list[bitarray]: The output list of bitarray chunks
    """
    number_of_bits_in_array = len(bit_array)
    number_of_chunks = ceil(number_of_bits_in_array/bits_per_chunk)
    output_bitarray_list = []

    if debug:
        print(f"Number of bits in the array: {number_of_bits_in_array}")
        print(f"Number of {bits_per_chunk}-bit chunks: {number_of_chunks}")

    for _ in range(0,number_of_chunks):
        bitarray_chunk = bitarray()
        for _ in range(0,bits_per_chunk):
            if len(bit_array) > 0:
                bitarray_chunk.append(bit_array.pop(0))
        output_bitarray_list.append(bitarray_chunk)

    return output_bitarray_list


def test_regression_encrypt_decrypt():

    key = randbits(256).to_bytes(32, 'little')
    message = "Attack at Dawn!"
    ciphertext = encryptMessage(key, message)
    decrypted_message = decryptMessage(key, ciphertext)

    assert message == decrypted_message.decode(text_encoding)